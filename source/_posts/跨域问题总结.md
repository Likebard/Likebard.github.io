---
title: 跨域问题总结
date: 2020-08-13 10:32:42
tags: web
---

## 一、跨域的由来： 同源策略

同源策略是浏览器的基本安全功能，目的是减少受到XSS， CSRF等攻击的可能性。同源是指"协议+域名+端口号"三者相同。

* 主域名和子域名之间也是跨域

* ip和域名之间也是跨域

__同源策略限制的内容:__

* 本地存储数据: Cookie, LocalStorage, indexDB等

* DOM节点

* AJAX网络请求
<!--more-->
__有三个标签允许跨域加载资源：__

* `<img src=xxx>`

* `<link href=xxx>`

* `<script src=xxx>`

## 二、常见跨域场景

## 三、跨域各解决方案

### 1. jsonp

#### 原理

利用`<script>`标签没有跨域限制的特殊性，从其他来源获取数据.

#### 优缺点

JSONP优点是简单兼容性好，__缺点是仅支持get方式具有局限性，不安全可能会遭受XSS攻击__。`[?]`

#### 实现流程

* 本地定义一个函数callback，传参为data

* script标签向非同源的服务器端发起请求，服务器端返回字符串。该文件中调用了方法callback，并传入data数据

* 前端拿到js文件之后就会执行，此时就获得了第三方后端传回来的数据
  
### 2. cors

__CORS需要浏览器和后端同时支持。IE8和9需要通过XDomainRequest来实现。__

* 服务端设置Access-Control-Allow-Origin就可以开启CORS。该属性表明哪些Origin(域名)可以访问资源

* Access-Control-Allow-Credentials: 布尔值，true允许客户端携带cookie，使用他的时候前端也要同时设置xhr.withCredentials = true。这样才能允许把cookie发到服务器

* Access-Control-Allow-Headers： 允许设置的头部信息

* Access-Control-Allow-Methods： 设置允许请求的Methods方法

* Access-Control-Expose-Headers： 允许客户端获取的Headers头部key。
CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。

需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。

#### 简单请求

##### 只要满足以下两大条件就属于简单请求（就是可以通过Form表单来实现的请求）

1. 使用下列方法之一：

* GET
* HEAD
* POST
  
2. Content-Type的值仅限于下列三者之一:

* text/plain
* multipart/form-data
* application/x-www-form-urlencoded

#### 复杂请求
不符合简单请求的即为复杂请求，在正式通信之前，增加一次HTTP查询请求，称为"预检"，使用Option方法，通过该请求来知道服务端是否允许跨域。

#### 区分简单请求和非简单请求的动机

* 对于简单请求而言，由于其可以通过Form发送，因此预检也不能禁止其跨源行为。
* 对于非简单请求而言：

1. 节省后端计算量：请求的数据量可以很大，因此提出option预检方案，先询问服务器是否可以跨域，假如跨域允许，再发送正式请求。

### 3.postMessage

postMessage可以用于解决如下问题:
  
* 页面和其新打开的窗口之间通信
* 窗口和窗口之间的通信
* 页面和其嵌套的iframe之间通信
* 上述三者之间的跨域通信

总结起来就是 __postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。__
`otherWindow.postMessage(message, targetOrigin, [transfer]);`

* message: 将要发送到其他 window的数据.
* targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。
* transfer(__可选__)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。

### 4.websocket

Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 __WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据__。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。
原生WebSocket API使用起来不太方便，我们可以使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

### 5.后端代理

* Node中间件代理
* Nginx反向代理

### 6. window.name / location.hash / document.domain + iframe

* window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）.
* location.hash跨域以url中的hash值为载体，在子iframe中拿取父Window的hash值，实现父传子，在子iframe中也可以改变父Window的URL hash值，父窗口用onhashchange监听hash值的变化，即可实现子传父。
* document.domain这种方法只能用于二级域名相同的情况下，比如a.test.com和b.test.com适用于该方式。 只需要给页面添加 document.domain ='test.com' 表示二级域名都相同就可以实现跨域。

## 总结

* CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案

* JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

* 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。

* 日常工作中，用得比较多的跨域方案是cors和nginx反向代理